<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Asynchronous I/O with Protocol Class Abstractions &mdash; PyMOTW 3</title>

    <link rel="stylesheet" href="../_static/pure-min.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/font-awesome/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pymotw.css" type="text/css">

    <link rel="shortcut icon" type="image/png" href="../_static/favicon.png">

    <link rel="alternate" type="application/atom+xml"
          title="Doug Hellmann"
          href="http://feeds.doughellmann.com/DougHellmann" />
    <link rel="alternate" type="application/atom+xml"
          title="PyMOTW Updates"
          href="http://feeds.doughellmann.com/PyMOTW" />

    <meta name="verify-v1" content="5saTcOa2HLac4V85yUg3SARfun1PqT5Upu7IR/6fpv4="/>

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@pymotw" />
    <meta name="twitter:title" content="Asynchronous I/O with Protocol Class Abstractions" />
    <meta name="twitter:image" content="https://pymotw.com/3/_static/logo-large.png" />

  </head>
  <body>

    <div class="pure-menu pure-menu-open pure-menu-horizontal" id="site-menu">
      <a class="pure-menu-heading" href="../index.html"><img src="../_static/logo.png"> PyMOTW-3</a>

      <ul id="top-menu">
        <li class="pure-menu-selected"><a href="../py-modindex.html"><i class="fa fa-list fa-lg"></i> Module Index</a></li>
        <li class="pure-menu-selected"><a href="../genindex.html"><i class="fa fa-italic fa-lg"></i> Index</a></li>
        <li class="pure-menu-selected"><a class="sociallink" href="http://www.twitter.com/pymotw"
       title="Twitter">
      <i class="fa fa-twitter fa-lg"></i></a></a>
        <li class="pure-menu-selected"><a class="sociallink" href="http://feeds.doughellmann.com/PyMOTW"
       title="Subscribe via RSS">
      <i class="fa fa-rss-square fa-lg"></i></a></li>
      </ul>

    </div>

    <div class="pure-menu pure-menu-open pure-menu-vertical" id="breadcrumbs-menu">
      
      <ul id="breadcrumbs">
        <li class="pure-menu-selected"><a href="../concurrency.html"><i class="fa fa-arrow-circle-up"></i> Concurrency with Processes, Threads, and Coroutines</a></li>
        <li class="pure-menu-selected"><a href="index.html"><i class="fa fa-arrow-circle-up"></i> asyncio — Asynchronous I/O, event loop, and concurrency tools</a></li>
      </ul>
    </div>

    <div class="pure-g-r" id="content-container">

      <div class="pure-u-3-4">
        <div class="content">
          
  <div class="section" id="asynchronous-i-o-with-protocol-class-abstractions">
<h1>Asynchronous I/O with Protocol Class Abstractions<a class="headerlink" href="#asynchronous-i-o-with-protocol-class-abstractions" title="Permalink to this headline">¶</a></h1>
<p>Up to this point the examples have all avoided mingling concurrency
and I/O operations to focus on one concept at a time. However,
switching contexts when I/O blocks is one of the primary use cases for
<code class="docutils literal notranslate"><span class="pre">asyncio</span></code>. Building on the concurrency concepts already
introduced, this section examines two sample programs implementing a
simple echo server and client, similar to the examples used in the
<a class="reference internal" href="../socket/index.html#module-socket" title="socket: Network communication"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> and <a class="reference internal" href="../socketserver/index.html#module-socketserver" title="socketserver: Creating network servers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socketserver</span></code></a> sections. A client can connect
to the server, send some data, and then receive the same data as a
response. Each time an I/O operation is initiated, the executing code
gives up control to the event loop, allowing other tasks to run until
the I/O is ready.</p>
<div class="section" id="echo-server">
<h2>Echo Server<a class="headerlink" href="#echo-server" title="Permalink to this headline">¶</a></h2>
<p>The server starts by importing the modules it needs to set up
<code class="docutils literal notranslate"><span class="pre">asyncio</span></code> and <a class="reference internal" href="../logging/index.html#module-logging" title="logging: Report status, error, and informational messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>, and then it creates an event loop
object.</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">asyncio_echo_server_protocol.py</span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">SERVER_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(name)s</span><span class="s1">: </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">)</span>

<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>It then defines a subclass of <code class="docutils literal notranslate"><span class="pre">asyncio.Protocol</span></code> to handle
client communication. The protocol object’s methods are invoked based
on events associated with the server socket.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EchoServer</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
</pre></div>
</div>
<p>Each new client connection triggers a call to
<code class="docutils literal notranslate"><span class="pre">connection_made()</span></code>. The transport argument is an instance of
<code class="docutils literal notranslate"><span class="pre">asyncio.Transport</span></code>, which provides an abstraction for doing
asynchronous I/O using the socket. Different types of communication
provide different transport implementations, all with the same
API. For example, there are separate transport classes for working
with sockets and for working with pipes to subprocesses. The address
of the incoming client is available from the transport through
<code class="docutils literal notranslate"><span class="pre">get_extra_info()</span></code>, an implementation-specific method.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">&#39;peername&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span>
            <span class="s1">&#39;EchoServer_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;connection accepted&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>After a connection is established, when data is sent from the client
to the server the <code class="docutils literal notranslate"><span class="pre">data_received()</span></code> method of the protocol is
invoked to pass the data in for processing. Data is passed as a byte
string, and it is up to the application to decode it in an appropriate
way. Here the results are logged, and then a response is sent back to
the client immediately by calling <code class="docutils literal notranslate"><span class="pre">transport.write()</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;received </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;sent </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<p>Some transports support a special end-of-file indicator (“EOF”). When
an EOF is encountered, the <code class="docutils literal notranslate"><span class="pre">eof_received()</span></code> method is called. In
this implementation, the EOF is sent back to the client to indicate
that it was received. Because not all transports support an explicit
EOF, this protocol asks the transport first whether it is safe to send
EOF.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">eof_received</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;received EOF&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">can_write_eof</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write_eof</span><span class="p">()</span>
</pre></div>
</div>
<p>When a connection is closed, either normally or as the result of an
error, the protocol’s <code class="docutils literal notranslate"><span class="pre">connection_lost()</span></code> method is called. If
there was an error, the argument contains an appropriate exception
object. Otherwise it is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;ERROR: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;closing&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connection_lost</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two steps to starting the server. First the application
tells the event loop to create a new server object using the protocol
class and the hostname and socket on which to listen. The
<code class="docutils literal notranslate"><span class="pre">create_server()</span></code> method is a coroutine, so the results must be
processed by the event loop in order to actually start the
server. Completing the coroutine produces a <code class="docutils literal notranslate"><span class="pre">asyncio.Server</span></code>
instance tied to the event loop.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the server and let the loop finish the coroutine before</span>
<span class="c1"># starting the real event loop.</span>
<span class="n">factory</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">EchoServer</span><span class="p">,</span> <span class="o">*</span><span class="n">SERVER_ADDRESS</span><span class="p">)</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;starting up on </span><span class="si">{}</span><span class="s1"> port </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">SERVER_ADDRESS</span><span class="p">))</span>
</pre></div>
</div>
<p>Then the event loop needs to be run in order to process events and
handle client requests. For a long-running service, the
<code class="docutils literal notranslate"><span class="pre">run_forever()</span></code> method is the simplest way to do this.  When the
event loop is stopped, either by the application code or by signaling
the process, the server can be closed to clean up the socket properly,
and then the event loop can be closed to finish handling any other
coroutines before the program exits.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Enter the event loop permanently to handle all connections.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;closing server&#39;</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">wait_closed</span><span class="p">())</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;closing event loop&#39;</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="echo-client">
<h2>Echo Client<a class="headerlink" href="#echo-client" title="Permalink to this headline">¶</a></h2>
<p>Constructing a client using a protocol class is very similar to
constructing a server.  The code again starts by importing the modules
it needs to set up <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> and <a class="reference internal" href="../logging/index.html#module-logging" title="logging: Report status, error, and informational messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>, and then
creating an event loop object.</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">asyncio_echo_client_protocol.py</span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">MESSAGES</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">b</span><span class="s1">&#39;This is the message. &#39;</span><span class="p">,</span>
    <span class="sa">b</span><span class="s1">&#39;It will be sent &#39;</span><span class="p">,</span>
    <span class="sa">b</span><span class="s1">&#39;in parts.&#39;</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">SERVER_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(name)s</span><span class="s1">: </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;main&#39;</span><span class="p">)</span>

<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>The client protocol class defines the same methods as the server, with
different implementations. The class constructor accepts two
arguments, a list of the messages to send and a <code class="docutils literal notranslate"><span class="pre">Future</span></code>
instance to use to signal that the client has completed a cycle of
work by receiving a response from the server.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EchoClient</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">messages</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages</span> <span class="o">=</span> <span class="n">messages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;EchoClient&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">future</span>
</pre></div>
</div>
<p>When the client successfully connects to the server, it starts
communicating immediately.  The sequence of messages is sent one at a
time, although the underlying networking code may combine multiple
messages into one transmission. When all of the messages are
exhausted, an EOF is sent.</p>
<p>Although it appears that the data is all being sent immediately, in
fact the transport object buffers the outgoing data and sets up a
callback to actually transmit when the socket’s buffer is ready to
receive data. This is all handled transparently, so the application
code can be written as though the I/O operation is happening right
away.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">&#39;peername&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;connecting to </span><span class="si">{}</span><span class="s1"> port </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># This could be transport.writelines() except that</span>
        <span class="c1"># would make it harder to show each part of the message</span>
        <span class="c1"># being sent.</span>
        <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">messages</span><span class="p">:</span>
            <span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;sending </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">transport</span><span class="o">.</span><span class="n">can_write_eof</span><span class="p">():</span>
            <span class="n">transport</span><span class="o">.</span><span class="n">write_eof</span><span class="p">()</span>
</pre></div>
</div>
<p>When the response from the server is received, it is logged.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;received </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<p>And when either an end-of-file marker is received or the connection is
closed from the server’s side, the local transport object is closed
and the future object is marked as done by setting a result.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">eof_received</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;received EOF&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;server closed connection&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connection_lost</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
</pre></div>
</div>
<p>Normally the protocol class is passed to the event loop to create the
connection. In this case, because the event loop has no facility for
passing extra arguments to the protocol constructor, it is necessary
to create a <code class="docutils literal notranslate"><span class="pre">partial</span></code> to wrap the client class and pass the list of
messages to send and the <code class="docutils literal notranslate"><span class="pre">Future</span></code> instance. That new callable
is then used in place of the class when calling
<code class="docutils literal notranslate"><span class="pre">create_connection()</span></code> to establish the client connection.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">client_completed</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>

<span class="n">client_factory</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
    <span class="n">EchoClient</span><span class="p">,</span>
    <span class="n">messages</span><span class="o">=</span><span class="n">MESSAGES</span><span class="p">,</span>
    <span class="n">future</span><span class="o">=</span><span class="n">client_completed</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">factory_coroutine</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span>
    <span class="n">client_factory</span><span class="p">,</span>
    <span class="o">*</span><span class="n">SERVER_ADDRESS</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To trigger the client to run, the event loop is called once with the
coroutine for creating the client and then again with the
<code class="docutils literal notranslate"><span class="pre">Future</span></code> instance given to the client to communicate when it is
finished. Using two calls like this avoids having an infinite loop in
the client program, which likely wants to exit after it has finished
communicating with the server. If only the first call was used to wait
for the coroutine to create the client, it might not process all of
the response data and clean up the connection to the server properly.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;waiting for client to complete&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">factory_coroutine</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">client_completed</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;closing event loop&#39;</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="output">
<h2>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<p>Running the server in one window and the client in another produces
the following output.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 asyncio_echo_client_protocol.py
asyncio: Using selector: KqueueSelector
main: waiting for client to complete
EchoClient: connecting to ::1 port 10000
EchoClient: sending b&#39;This is the message. &#39;
EchoClient: sending b&#39;It will be sent &#39;
EchoClient: sending b&#39;in parts.&#39;
EchoClient: received b&#39;This is the message. It will be sent in parts.&#39;
EchoClient: received EOF
EchoClient: server closed connection
main: closing event loop

$ python3 asyncio_echo_client_protocol.py
asyncio: Using selector: KqueueSelector
main: waiting for client to complete
EchoClient: connecting to ::1 port 10000
EchoClient: sending b&#39;This is the message. &#39;
EchoClient: sending b&#39;It will be sent &#39;
EchoClient: sending b&#39;in parts.&#39;
EchoClient: received b&#39;This is the message. It will be sent in parts.&#39;
EchoClient: received EOF
EchoClient: server closed connection
main: closing event loop

$ python3 asyncio_echo_client_protocol.py
asyncio: Using selector: KqueueSelector
main: waiting for client to complete
EchoClient: connecting to ::1 port 10000
EchoClient: sending b&#39;This is the message. &#39;
EchoClient: sending b&#39;It will be sent &#39;
EchoClient: sending b&#39;in parts.&#39;
EchoClient: received b&#39;This is the message. It will be sent in parts.&#39;
EchoClient: received EOF
EchoClient: server closed connection
main: closing event loop
</pre></div>
</div>
<p>Although the client always sends the messages separately, the first
time the client runs the server receives one large message and echoes
that back to the client. These results vary in subsequent runs, based
on how busy the network is and whether the network buffers are flushed
before all of the data is prepared.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 asyncio_echo_server_protocol.py
asyncio: Using selector: KqueueSelector
main: starting up on localhost port 10000
EchoServer_::1_63347: connection accepted
EchoServer_::1_63347: received b&#39;This is the message. It will be sent in parts.&#39;
EchoServer_::1_63347: sent b&#39;This is the message. It will be sent in parts.&#39;
EchoServer_::1_63347: received EOF
EchoServer_::1_63347: closing

EchoServer_::1_63387: connection accepted
EchoServer_::1_63387: received b&#39;This is the message. &#39;
EchoServer_::1_63387: sent b&#39;This is the message. &#39;
EchoServer_::1_63387: received b&#39;It will be sent in parts.&#39;
EchoServer_::1_63387: sent b&#39;It will be sent in parts.&#39;
EchoServer_::1_63387: received EOF
EchoServer_::1_63387: closing

EchoServer_::1_63389: connection accepted
EchoServer_::1_63389: received b&#39;This is the message. It will be sent &#39;
EchoServer_::1_63389: sent b&#39;This is the message. It will be sent &#39;
EchoServer_::1_63389: received b&#39;in parts.&#39;
EchoServer_::1_63389: sent b&#39;in parts.&#39;
EchoServer_::1_63389: received EOF
EchoServer_::1_63389: closing
</pre></div>
</div>
</div>
</div>



        <div id="footer-nav">
<a id="prev-link" href="synchronization.html"
   title="previous chapter"><i class="fa fa-arrow-circle-left"></i> Synchronization Primitives</a>
<a id="next-link" href="io_coroutine.html"
   title="next chapter">Asynchronous I/O Using Coroutines and Streams <i class="fa fa-arrow-circle-right"></i></a>
        </div>

        </div>
      </div>

      <div class="pure-u-1-4">
        <div class="sidebar-wrapper">
          <div class="sidebar">
<div id="sidebar-toc">
  <h5>Quick Links</h5>
  <ul>
    
    <li><a href="#echo-server"><i class="fa fa-caret-right"></i>Echo Server</a></li>
    
    <li><a href="#echo-client"><i class="fa fa-caret-right"></i>Echo Client</a></li>
    
    <li><a href="#output"><i class="fa fa-caret-right"></i>Output</a></li>
    
  </ul>
</div>

          </div>
          <div class="sidebar"><div id="sidebar-last-updated">
  This page was last updated 2016-12-26.
</div>

          </div>
          <div class="sidebar">
<div id="sidebar-nav">
  <h5>Navigation</h5>
  <ul>
    <li><a href="synchronization.html"
           title="previous chapter"><i class="fa fa-arrow-circle-left"></i>Synchronization Primitives</a></li>
    <li><a href="io_coroutine.html"
           title="next chapter"><i class="fa fa-arrow-circle-right"></i>Asynchronous I/O Using Coroutines and Streams</a></li>
  </ul>
</div>
          </div>
          <div class="sidebar"><div id="sidebar-book"><a target="new" href="https://doughellmann.com/blog/the-python-3-standard-library-by-example/"><img src="../_static/book-cover-image-med.jpg"><br>Get the book</a></div>
          </div>
          <div class="sidebar"><div id="sidebar-example-disclaimer">
<p>The output from all the example programs
from PyMOTW-3 has been generated with Python 3.7.9, unless
otherwise noted. Some of the features described here may not be
available in earlier versions of Python.</p>
<p>Looking for <a href="/2/">examples for Python 2</a>?</p>
</div>
          </div>

        </div>
      </div>

    </div>

    <div class="pure-g-r" id="footer">

      <div class="pure-u-1-3">
        <div class="footer-list">
            <h4>This Site</h4>
            <ul>
              <li><a href="../py-modindex.html"><i class="fa fa-list fa-lg"></i> Module Index</a></li>
              <li><a href="../genindex.html"><i class="fa fa-italic fa-lg"></i> Index</a></li>
            </ul>
        </div>
      </div><div class="pure-u-1-3">
          <div class="footer-content">
            <div class="socialmedia">
              <a class="sociallink" href="../index.html"
       title="Home">
      <i class="fa fa-home fa-lg"></i></a>
              <a class="sociallink" href="../about.html"
       title="About">
      <i class="fa fa-user fa-lg"></i></a>
              <a class="sociallink" href="http://www.twitter.com/pymotw"
       title="Twitter">
      <i class="fa fa-twitter fa-lg"></i></a>
              <a class="sociallink" href="http://feeds.doughellmann.com/PyMOTW"
       title="Subscribe via RSS">
      <i class="fa fa-rss-square fa-lg"></i></a>
              <a class="sociallink" href="http://feedburner.google.com/fb/a/mailverify?uri=PyMOTW&amp;loc=en_US"
       title="Subscribe via Email">
      <i class="fa fa-envelope fa-lg"></i></a>
            </div>

            <div class="copyright">
              <a rel="author" href="../about.html">&copy; Copyright 2021, Doug Hellmann</a>
            </div>

            <div class="cc"><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US" rel="license"><img alt="Creative Commons License BY-NC-SA" style="border-width:0; align: center;" width="88" height="31" src="data:image/png;base64,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"/></a>
            </div>

          </div></div><div class="pure-u-1-3">
          <div class="footer-list">
            <h4>Other Writing</h4>
            <ul>
              <li><a href="https://doughellmann.com/"><i class="fa fa-pencil fa-lg"></i> Blog</a></li>
              <li><a href="https://doughellmann.com/blog/the-python-standard-library-by-example/"><i class="fa fa-book fa-lg"></i> The Python Standard Library By Example</a></li>
            </ul>
          </div>
        </div><script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-38546875-3', 'pymotw.com');
  ga('send', 'pageview');
</script>

  </body>
</html>